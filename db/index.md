# Index
Index 는 데이터베이스의 성능에 있어서 중요한 부분이다. MySQL 에서는 인덱싱이나 검색 방식에 따라 스토리지 엔진을 선택해야 할 수도
있다. 

## Index 란
DBMS 가 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 많이 걸린다. 
그래서 칼럼의 값과 해당  해코드가 저장된 주소를 key-value 쌍으로 인덱스를 만들어 두어 빠른 검색이 가능하도록 한다. 
또한 인덱스가 많아져도 최대한 빠르게 찾아낼 수 있게 컬럼의 값을 주어진 순서대로 미리 **정렬**하여 보관해둔다. 

당연하세도 데이터가 저장될때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만, 이미 정렬되어 있기 때문에 빠르게 원하는 값을 
가져오는 것이 가능하다. 따라서 DBMS 의 인덱스가 많은 테이블은 `INSERT`, `UPDATE`, `DELETE` 문장의 처리는 느려지지만, SELECT 문장은 
매우 빠르게 처리하는 것이 가능하다. 

- DBMS 에서 인덱스는 저장 성능을 희생하고, 대신 데이터의 읽기 속도를 높이는 기능
- 테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 얼마나 희생 가능하고, 읽기 속도를 얼마나 더 빠르게 해야하는지 여부에 따라 결정

## B-Tree 인덱스
- 컬럼의 값을 변형하지 않고, 원래의 값을 인덱싱하는 알고리즘
- 대부분의 인덱스는 거의 B-Tree 를 사용

B-Tree 는 트리 구조의 최상위에 하나의 **루트노드**가 존재하고 그 하위에 자식 노드가 붙어있는 형태이다. 가장 하위에 있는 노드를 **리프 노드**라고 
하고, 루트도 아니고 리프도 아닌 중산의 노드를 **브랜치 노드**라 한다. DB 에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 
인덱스의 리프 노드는 실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있다. 
> 이때 인덱스의 키 값은 모두 정렬되어 있지만 데이터 파일의 레코드는 정렬되어 있지 않다. 

### 인덱스 키 추가
B-Tree 에 저장될 떄는 저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색해야 한다. 
저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree 의 리프 노드에 저장한다. 
리프노드가 꽉 차서 더 이상 저장할 수 없을 때는 리프 노드가 split 되어야 하는데 이는 상위의 브랜치 노드까지 처리 되어야 하는 과정이라 
상대적으로 B-Tree 는 쓰기 작업(새로운 키를 추가하는 작업)에 비용이 많이 든다고 한다.  

### 인덱스 키 삭제
해당 키 값이 저장된 B-Tree 의 리프 노드를 찾아서 그냥 삭제 마크만 하면 된다. 삭제 마킹된 인덱스 공간은 그대로 방치되거나 재활용할 수 있다. 
인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로 이 작업 역시 디스크 I/O 가 필요한 작업니다. 

### 인덱스 키 변경
인덱스 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree 의 키 값이 변경되는 경우에 
단순히 인덱스 상의 키 값만 변경하는 것은 불가능 하고, 먼저 키 값을 삭제하고 다시 키 값을 추가하는 형태로 처리된다. 

### 인덱스 키 검색
검색 작업은 B-Tree 의 루트 노드부터 시작해 브랜치를 거쳐 최종 리프노드 까지 이동하면서 비교 작업을 수행한다(**트리 탐색 Tree traversal**).
B-Tree 인덱스를 이용한 검색은 완전히 일치하거나 값의 앞부분만 일치하는 경우에 사용할 수 있고, `!=`, `<>` 비교나 값의 뒷 부분이 일치하는 경우에는 
사용할 수 없다. 또한 인덱스의 키 값을 변형하여 비교하는 경우에는 인덱스를 사용 할 수 없다. 

## Hash 인덱스
- 컬럼의 값으로 해시 값을 계싼해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원
- 값을 변형해서 인덱싱하므로, prefix 일치와 같이 값의 일부만 검색하고자 할 때는 해시 인덱스 사용 불가
- 메모리 기반의 데이터베이스에서 많이 사용

## Fractal-Tree 인덱스
- B-Tree 의 단점을 보완하기 위한 알고리즘
- 값을 변형하기 않고 인덱싱하며 범용적인 목적으로 사용하는 점은 B-Tree 와 유사하지만, 데이터가 저장되거나 삭제될 때 처리비용을 상당히 줄일 수 있음

